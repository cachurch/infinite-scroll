"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TRUE = 'true';
const FALSE = 'false';
class ArgumentCollection {
    constructor(commandName) {
        this.commandName = commandName;
        this.args = {};
        this.flags = [];
    }
    get(name) {
        return this.args[name];
    }
    isExistsArgument(name) {
        return !!this.args[name];
    }
    isExistsFlag(name) {
        return this.flags.includes(name);
    }
    get command() {
        return this.commandName;
    }
    addFlag(name) {
        this.flags.push(name);
        return this;
    }
    add(name, value) {
        this.args[name] = value;
        return this;
    }
}
exports.ArgumentCollection = ArgumentCollection;
class CommandParser {
    constructor() {
        this.bool = [TRUE, FALSE];
        this.regex = {
            command: /^([A-z:]+)$/m,
            argumentName: /^--([A-z][A-z0-9-]*)$/m,
            quotedValue: /^'([^']*)'|"([^"]*)"|`([^`]*)`$/m,
            flag: /^-([A-z][A-z0-9-]*)$/m,
        };
    }
    parse(line) {
        const segments = line.split(/[\s\t]+/m).map(ln => ln.trim()).filter(v => !!v);
        const commandName = segments.shift().toLowerCase();
        const matchCommand = commandName.match(this.regex.command);
        if (!matchCommand || matchCommand.length !== 2) {
            throw new Error('Invalid command');
        }
        const collection = new ArgumentCollection(commandName);
        for (const segment of segments) {
            const subSegments = segment.split('=');
            const name = subSegments.shift();
            const argNameMatch = name.match(this.regex.argumentName);
            if (argNameMatch && argNameMatch.length === 2) {
                if (subSegments.length === 1 && subSegments[0].length) {
                    const argValue = subSegments.join('=');
                    if (this.bool.includes(argValue)) {
                        collection.add(argNameMatch.pop(), argValue === TRUE);
                        continue;
                    }
                    const quotedValueMatch = argValue.match(this.regex.quotedValue);
                    if (quotedValueMatch && quotedValueMatch.length >= 2) {
                        collection.add(argNameMatch.pop(), quotedValueMatch.pop());
                        continue;
                    }
                    collection.add(argNameMatch.pop(), argValue);
                    continue;
                }
                collection.add(argNameMatch.pop(), true);
                continue;
            }
            const flagNameMatch = name.match(this.regex.flag);
            if (!flagNameMatch) {
                throw new Error(`Invalid argument ${name}`);
            }
            collection.addFlag(flagNameMatch.pop());
        }
        return collection;
    }
}
exports.CommandParser = CommandParser;
console.log(new CommandParser().parse('envdist --arg=val --arg2="fsdf" --arg2=`fsdf` --argBool --fal=false -f -d -g  '));
//# sourceMappingURL=command.parser.js.map
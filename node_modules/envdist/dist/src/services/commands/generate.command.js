"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("./command");
const exceptions_1 = require("../../exceptions");
const help_command_1 = require("./help.command");
const parser_1 = require("../parser");
const generator_1 = require("../generator");
const enums_1 = require("../../enums");
class GenerateCommand extends command_1.AbstractCommand {
    async execute() {
        try {
            const args = new parser_1.ArgumentParser().parse(process.argv);
            const settings = new parser_1.SettingsParser().parse(process.cwd());
            await new generator_1.GeneratorFactory(this.console)
                .create(this.resolveStrategy(settings, args))
                .generate(settings, args);
            this.console.info('Env file successful generated.');
            this.console.exit();
        }
        catch (e) {
            if (e instanceof exceptions_1.InvalidArgumentsException) {
                return new help_command_1.HelpCommand().execute();
            }
            this.console.error(e.message);
            this.console.exit();
        }
    }
    resolveStrategy(settings, args) {
        if (!settings.strategies) {
            return args.strategy;
        }
        const manual = settings.strategies.manual;
        const currentEnv = process.env[generator_1.ENV_VAR] || '';
        if (Array.isArray(manual) && manual.includes(currentEnv)) {
            return enums_1.StrategiesEnum.Manual;
        }
        const variables = settings.strategies.variables;
        if (Array.isArray(variables) && variables.includes(currentEnv)) {
            return enums_1.StrategiesEnum.Variables;
        }
        return args.strategy;
    }
}
exports.GenerateCommand = GenerateCommand;
//# sourceMappingURL=generate.command.js.map